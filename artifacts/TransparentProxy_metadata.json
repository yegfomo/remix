{
	"compiler": {
		"version": "0.8.30+commit.73712a01"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_implementation",
						"type": "address"
					}
				],
				"stateMutability": "nonpayable",
				"type": "constructor"
			},
			{
				"stateMutability": "payable",
				"type": "fallback"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "newImplementation",
						"type": "address"
					}
				],
				"name": "upgrade",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "words",
				"outputs": [
					{
						"internalType": "string",
						"name": "",
						"type": "string"
					}
				],
				"stateMutability": "view",
				"type": "function"
			}
		],
		"devdoc": {
			"kind": "dev",
			"methods": {},
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {},
			"notice": "代理合约中的“选择器冲突”，以及如何利用透明代理避免这个问题。透明代理的逻辑简单，通过限制管理员调用逻辑合约解决“选择器冲突”问题。 它也有缺点，每次用户调用函数时，都会多一步是否为管理员的检查，消耗更多gas。但瑕不掩瑜，透明代理仍是大多数项目方选择的方案. 由于代理合约和逻辑合约是两个合约，就算他们之间存在“选择器冲突”也可以正常编译，这可能会导致很严重的安全事故。 举个例子，如果逻辑合约的a函数和代理合约的升级函数的选择器相同，那么管理人就会在调用a函数的时候， 将代理合约升级成一个黑洞合约，后果不堪设想。 目前，有两个可升级合约标准解决了这一问题：透明代理Transparent Proxy和通用可升级代理UUPS。*",
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"contracts/TransparentProxy.sol": "TransparentProxy"
		},
		"evmVersion": "prague",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": false,
			"runs": 200
		},
		"remappings": []
	},
	"sources": {
		"contracts/TransparentProxy.sol": {
			"keccak256": "0xedc1fb26b03d84890aa24840cd7aadc6def70539a73873baf29fe4a165f8c6b2",
			"license": "MIT",
			"urls": [
				"bzz-raw://40dfc4d651b993a5441a1654df1d3351f5e627e9d107b8659a506b72af61710b",
				"dweb:/ipfs/QmWse39Gm384Mwz8FtcKjUSVc7dr3SBgkuQee1GYQTBpsR"
			]
		}
	},
	"version": 1
}